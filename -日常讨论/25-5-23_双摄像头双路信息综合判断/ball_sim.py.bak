'''
台球物理碰撞模拟

- 定义屏幕尺寸（1920*1080分辨率）
- 球桌四个边界（用坐标表示）
- 定义台球直径尺寸

- 定义直线运动速度动量衰减率
- 定义撞击边界速度动量衰减率
- 定义台球相互撞击速度动量衰减率

定义好以上超参数后，初始化一些台球和初始速度方向，然后可视化模拟台球在球桌中的运动轨迹

'''

import pygame
import math
import random

# 初始化 pygame
pygame.init()

# 显示设置
SIM_WIDTH, SIM_HEIGHT = 1920, 1080  # 模拟坐标范围
WINDOW_WIDTH, WINDOW_HEIGHT = 960, 540  # 实际可视化窗口大小（半屏）

SCALE_X = WINDOW_WIDTH / SIM_WIDTH
SCALE_Y = WINDOW_HEIGHT / SIM_HEIGHT

# 球桌边界（不规则四边形）
TABLE_BOUNDARY = [
    (120, 110),   # 左上角
    (1800, 200),  # 右上角
    (1900, 950),  # 右下角
    (110, 950),   # 左下角
]


# 球参数
BALL_RADIUS = 10  # 台球半径（逻辑坐标）
FRICTION = 0.995  # 直线运动动量衰减
WALL_BOUNCE_DAMPING = 0.9  # 边界反弹动量衰减
BALL_COLLISION_DAMPING = 0.95  # 球之间碰撞动量衰减


# 台球类
class Ball:
    def __init__(self, x, y, vx, vy, color=None):
        self.x = x  # 逻辑坐标
        self.y = y
        self.vx = vx
        self.vy = vy
        self.color = color if color else (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))

    def move(self):
        # 更新位置
        self.x += self.vx
        self.y += self.vy
        # 应用摩擦力
        self.vx *= FRICTION
        self.vy *= FRICTION

        # 撞击边界反弹（基于逻辑尺寸 SIM_WIDTH/HEIGHT）
        if self.x - BALL_RADIUS < 0 or self.x + BALL_RADIUS > SIM_WIDTH:
            self.vx = -self.vx * WALL_BOUNCE_DAMPING
            self.x = max(BALL_RADIUS, min(SIM_WIDTH - BALL_RADIUS, self.x))
        if self.y - BALL_RADIUS < 0 or self.y + BALL_RADIUS > SIM_HEIGHT:
            self.vy = -self.vy * WALL_BOUNCE_DAMPING
            self.y = max(BALL_RADIUS, min(SIM_HEIGHT - BALL_RADIUS, self.y))

    def draw(self, screen, scale_x, scale_y):
        # 缩放坐标
        draw_x = int(self.x * scale_x)
        draw_y = int(self.y * scale_y)
        draw_radius = int(BALL_RADIUS * (scale_x + scale_y) / 2)
        pygame.draw.circle(screen, self.color, (draw_x, draw_y), draw_radius)


# 台球模拟类
class BilliardsSimulation:
    def __init__(self, width=WINDOW_WIDTH, height=WINDOW_HEIGHT, ball_count=16):
        self.WINDOW_WIDTH = width
        self.WINDOW_HEIGHT = height
        self.scale_x = width / SIM_WIDTH
        self.scale_y = height / SIM_HEIGHT

        self.screen = pygame.display.set_mode((self.WINDOW_WIDTH, self.WINDOW_HEIGHT))
        pygame.display.set_caption("台球物理碰撞模拟")
        self.clock = pygame.time.Clock()
        self.balls = self.init_balls(ball_count)

        self.running = True

    def init_balls(self, count):
        balls = []
        for _ in range(count):
            x = random.randint(100, SIM_WIDTH - 100)
            y = random.randint(100, SIM_HEIGHT - 100)
            vx = random.uniform(-50, 50)  # 随机速度
            vy = random.uniform(-50, 50)  # 随机速度
            balls.append(Ball(x, y, vx, vy))
        return balls

    # 球之间碰撞检测
    def handle_collision(self, ball1, ball2):
        dx = ball2.x - ball1.x
        dy = ball2.y - ball1.y
        distance = math.hypot(dx, dy)

        if distance < 2 * BALL_RADIUS:
            # 归一化方向向量
            nx = dx / distance
            ny = dy / distance

            # 相对速度在法向方向上的分量
            dvx = ball1.vx - ball2.vx
            dvy = ball1.vy - ball2.vy
            impact_speed = dvx * nx + dvy * ny

            if impact_speed > 0:
                return  # 两球远离时不处理

            # 碰撞响应：动量守恒 + 简单衰减
            impulse = impact_speed * BALL_COLLISION_DAMPING
            ball1.vx -= impulse * nx
            ball1.vy -= impulse * ny
            ball2.vx += impulse * nx
            ball2.vy += impulse * ny

            # 避免重叠/修复重叠（简单分开）
            overlap = 2 * BALL_RADIUS - distance
            ball1.x -= nx * overlap / 2
            ball1.y -= ny * overlap / 2
            ball2.x += nx * overlap / 2
            ball2.y += ny * overlap / 2

    def shoot_ball(self, pos):
        x, y = pos
        vx = random.uniform(-50, 50)  # 随机速度
        vy = random.uniform(-50, 50)  # 随机速度
        new_ball = Ball(x, y, vx, vy)
        self.balls.append(new_ball)

    def run(self):
        while self.running:
            self.clock.tick(60)  # 控制帧率为60 FPS
            self.screen.fill((30, 30, 30))  # 深色背景

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False

                elif event.type == pygame.MOUSEBUTTONDOWN:
                    if event.button == 1:  # 左键点击
                        self.shoot_ball(event.pos)

            # 更新球运动
            for ball in self.balls:
                ball.move()

            # 球体间碰撞处理
            for i in range(len(self.balls)):
                for j in range(i + 1, len(self.balls)):
                    self.handle_collision(self.balls[i], self.balls[j])

            # 绘制球体
            for ball in self.balls:
                ball.draw(self.screen, self.scale_x, self.scale_y)

            pygame.display.flip()

        pygame.quit()

if __name__ == "__main__":
    '''
    运行脚本
    '''
    sim = BilliardsSimulation()
    sim.run()


