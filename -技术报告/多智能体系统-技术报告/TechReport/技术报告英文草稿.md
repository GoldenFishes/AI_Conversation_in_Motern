### Allen: Rethinking MAS Design through Step-Level Policy Autonomy



## Abstract

We intruduce a new Multi-Agent System (MAS) —— Allen, in order to address two core challenges in current MAS design: (1) improve system's policy autonomy, empowering agents to dynamically adapt their behavioral strategies, and (2) achieving the trade-off between collaborative efficiency, task supervision, and human oversight in complex network topologies. 

Our key insight involves redefining the minimal execution unit within MAS, enabling agents to autonomously assemble these units to form diverse operational modes. Concurrently, we construct a four-level state architecture encompassing Task, Stage, Agent, and Step layers. This structure collaboratively constrains system behaviors from both dual mission and execution perspectives, and achieving unification between topological optimization and progress controllability.

Allen achieves unprecedented policy autonomy, with the project open-sourced at: https://github.com/motern88/Allen



## 1. Introduction





## 2. Related Work





## 3. Agent's Internal Mechanisms





## 4. Inter-Agent Collaboration Mechanism





## 5. Disscussion

**Agents Direct Communication.**

It is particularly noteworthy that in our Allen architecture's MAS, both the initiation and termination of inter-agent communication are determined by Agents. To be exact, it's by the Agent that created the most recent message. An Agent can proactively add a 'Send Message' action to create message for other Agents. Within the 'Send Message' capability, the Agent may also decide whether the message requires a reply. The absence of a reply requirement typically signifies the end of that communication instance.

This closely mirrors human behavior: we may interrupt colleagues at will during work simply because we choose to, without even asking first. Consequently, in Allen's architecture, prompt engineering must be carefully designed to prevent Agents from over-communicating about small things. Each communication requires both participating Agents to temporarily allocate their threads to the communication steps (Send Message and Process Message), diverting resources from their primary tasks - particularly when step-locking mechanisms are triggered [[Appendix C](#Appendix C)] .

We also added another rule: Agents can only communicate if they're on the same Task. Agents from completely different tasks can't message each other directly—all message must pass through the Task State.

**Message Intervening Agent Actions**

Here we specify what forms of message-based intervention are allowed. We require the Agent to autonomously generate Actions based on message content. Specifically, we should not manually define how the Agent should respond to every non-command message, but instead allow it to make it's own decisions.

Thus, our message-handling logic leads to a decision branch that generates actions. Specifically, it adds a skill step called 'Decision', where the Decision Step plans immediate short-term steps to interact with the MAS environment.

To achieve this, we introduce a new decison branch at both ends of the Agent's message-handling logic: the Send Message and Process Message skills. These skills can now insert an additional Decision Step when needed to enable environment interaction, going beyond simply replying  to or understanding messages.

**Agent processes multi-stage tasks concurrently**

Our system does not restrict Agents from accepting tasks across multiple stages simultaneously. However, since the Agent executes Steps in a single-threaded sequential manner, handling multi-stage task does not improve overall efficiency. Instead, it may lead to interleaved execution of Steps from different stages, potentially prolonging each stages's completion time.

In terms of task focus, Agents closely mimic human work patterns. We should keep an Agent focused on a single task stage whenever possible. To prevent Agents from handing too many stages concurrently, we can instantiate multiple functionally similar Agents to achieve true parallelism.

**From Single-Agent System to Multi-Agent System**

From the perspective of policy autonomy, when our decision granularity shifts from workflow-level to agent-level, a single-Agent system naturally evolves into a multi-Agent system. At this point, you gain the ability to select different Agents based on specific needs - where each Agent embodies a distinct workflow.

**Allen enables simple iteration and optimization**

Our framework can accommodate any model-level optimizations, context-level improvements, or tool-level methods, as the July 2025 survey [[8](#References 8)] pointed out for iteration directions. Our architectural innovation lies in redefining the operation mode of Multi-Agent Systems, while all model policies, model experiences, context prompts, context memories, and other module improvements can be freely replaced to adapt to the latest research approaches.



## 6. Conclusion

We introduce the Allen framework, a novel Multi-Agent System. Within this framework, we propose using 'Step' as the minimal execution unit, enabling agents to iteratively execute their workflows step-by-step. This approach can generalize to most scenarios with unprecedented policy autonomy, only requiring interaction with the system’s manager agent and no code modifications.

Furthermore, the Allen framework implements a step-wise execution paradigm. Using four-level states to define and track complex tasks and multi-agent collaboration processes, it effectively balances collaboration efficiency, progress visibility, and human intervention capability.



## Author Contributions





## References

<a id="References 1"></a>

[1] Liu, Yue, et al. "Agent design pattern catalogue: A collection of architectural patterns for foundation model based agents." *Journal of Systems and Software* 220 (2025): 112278.

<a id="References 2"></a>

[2] Zhou, Han, et al. "Multi-agent design: Optimizing agents with better prompts and topologies." *arXiv preprint arXiv:2502.02533* (2025).

<a id="References 3"></a>

[3] LangChain AI. "LangChain." *GitHub*, https://github.com/langchain-ai/langchain. Accessed 25 Oct. 2022.

<a id="References 4"></a>

[4] Langgenius. "Diffy." *GitHub*, https://github.com/langgenius/dify. Accessed 25 May. 2023.

<a id="References 5"></a>

[5] Wu, Qingyun, et al. "Autogen: Enabling next-gen LLM applications via multi-agent conversations." *First Conference on Language Modeling*. 2024.

<a id="References 6"></a>

[6] Hong, Sirui, et al. "MetaGPT: Meta programming for a multi-agent collaborative framework." *The Twelfth International Conference on Learning Representations*. 2023.

<a id="References 7"></a>

[7] Elman, Jeffrey L. "Finding structure in time." *Cognitive science* 14.2 (1990): 179-211.

<a id="References 8"></a>

[8] Gao, Huan-ang, et al. "A Survey of Self-Evolving Agents: On Path to Artificial Super Intelligence." *arXiv preprint arXiv:2507.21046* (2025).





## Appendix



<a id="Appendix A"></a>

### A. Skills and Tools



#### A1. Skills



#### A2. Tools



<a id="Appendix B"></a>

### B. Presistent Memory





<a id="Appendix C"></a>

### C. Communication Step Lock

In our MAS, agents communicate with other components or agents through Send Message and Process Message skills executed at the Step level. To prevent dependent Steps (those requiring responses from pending Send Message operations) from executing prematurely and causing failures, we introduce the StepLock mechanism. 

The StepLock mechanism can suspend an agent's Step execution while awaiting critical message responses. Execution only resumes after all StepLocks are released (i.e., when all required message responses are successfully received). This ensures the logical dependencies between communication-dependent Steps and other Steps remain intact.

The StepLock mechanism in communication scenarios involves three core components: message reception logic (`AgentBase.received`) and Agent State, Send Message, and system message protocol (`Message`). We will systematically examine our key design consideration and the StepLock operation within those components.

**Message**

As the standard message format for inter-agent communication in our MAS, the Message dictionary includes two dedicated fields for StepLock coordination:

1. `waiting (Optional[List[str]])`
   (Sender-specified) Contains unique wait IDs corresponding to each receiver in `List[str]`
   - When the sender requires response(s): Generates a unique wait ID per receiver
   - Blocks all subsequent Steps until all wait IDs are released
   - Default: `None` (no waiting required)
2. `return_waiting_id (Optional[str])`
   (Receiver-specified in response) Echoes the sender's original wait ID
   - Mandatory inclusion when responding to messages with `waiting` IDs
   - Enables sender to release the corresponding wait lock
   - Default: `None` (no ID to return)

**Send Message**













